# 滚动窗口训练逻辑详解

## 一、滚动窗口的基本概念

滚动窗口（Rolling Window）是一种时间序列数据的训练方法，通过**滑动时间窗口**来模拟真实场景下的模型训练和评估过程。

### 为什么使用滚动窗口？

1. **模拟真实场景**：在实际应用中，我们只能使用历史数据训练模型，然后用模型预测未来
2. **避免数据泄露**：确保训练时不会使用未来数据
3. **评估模型稳定性**：通过多个时间窗口评估模型在不同时期的性能
4. **适应市场变化**：定期重新训练模型，适应市场环境的变化

## 二、滚动窗口的配置参数

根据 `config_industry_rotation.yaml` 的配置：

```yaml
rolling:
  train_months: 24    # 训练窗口：24个月
  valid_months: 1     # 验证窗口：1个月
  test_months: 1      # 测试窗口：1个月（当前未使用）
  step_months: 1      # 滚动步长：1个月
  min_samples: 100    # 最小样本数
```

### 参数说明

- **train_months (24个月)**：用于训练模型的历史数据长度
- **valid_months (1个月)**：用于验证模型性能的时间窗口
- **step_months (1个月)**：每次滚动前进的时间长度
- **min_samples (100)**：训练集的最小样本数，低于此值跳过该窗口

## 三、滚动窗口的生成逻辑

### 核心代码逻辑

```python
def generate_windows():
    start = pd.Timestamp(start_time)      # 数据开始时间：2015-01-01
    end = pd.Timestamp(end_time)          # 数据结束时间：2024-12-31
    train_offset = pd.DateOffset(months=24)  # 训练窗口：24个月
    valid_offset = pd.DateOffset(months=1)   # 验证窗口：1个月
    step = pd.DateOffset(months=1)          # 滚动步长：1个月
    
    # cursor 指向验证起点，前推 train_offset 即训练区间
    cursor = start + train_offset  # 初始位置：2017-01-01
    
    while cursor + valid_offset <= end:
        # 训练窗口：从 cursor 往前推 24 个月
        train_start = cursor - train_offset  # 2015-01-01
        train_end = cursor - 1天             # 2016-12-31
        
        # 验证窗口：从 cursor 开始的 1 个月
        valid_start = cursor                 # 2017-01-01
        valid_end = cursor + valid_offset - 1天  # 2017-01-31
        
        yield Window(train_start, train_end, valid_start, valid_end)
        
        # 滚动前进 1 个月
        cursor += step  # 下一个窗口：2017-02-01
```

### 时间线示意图

假设数据范围是 **2015-01-01 到 2024-12-31**：

```
时间轴：2015-01-01 ──────────────────────────────────→ 2024-12-31

窗口 0:
  训练: [2015-01-01 ──────────── 2016-12-31] (24个月)
  验证:                              [2017-01-01 ─── 2017-01-31] (1个月)
        ↑                            ↑
     train_start                  cursor (验证起点)

窗口 1 (滚动1个月后):
  训练: [2015-02-01 ──────────── 2017-01-31] (24个月)
  验证:                              [2017-02-01 ─── 2017-02-28] (1个月)
        ↑                            ↑
     train_start                  cursor (验证起点)

窗口 2 (再滚动1个月):
  训练: [2015-03-01 ──────────── 2017-02-28] (24个月)
  验证:                              [2017-03-01 ─── 2017-03-31] (1个月)

... 以此类推，直到 cursor + valid_offset > end
```

## 四、标签未来数据的问题

### 问题背景

标签表达式：`Ref($close, -10) / $close - 1` 表示**未来10天的收益率**

这意味着：
- 要计算 2017-01-20 的标签，需要用到 2017-01-30 的收盘价
- 如果验证窗口是 [2017-01-01, 2017-01-31]
- 那么 2017-01-22 之后的标签需要用到 2017-02-01 之后的数据（超出验证窗口）

### 解决方案：提前结束日期

```python
# 标签需要未来数据，需要提前结束日期
if label_future_days > 0:  # label_future_days = 10
    end_ts = end_ts - pd.Timedelta(days=label_future_days)
```

**示例**：
- 原始验证窗口：2017-01-01 到 2017-01-31
- 调整后验证窗口：2017-01-01 到 2017-01-21（提前10天）
- 这样确保所有标签都能在验证窗口内计算，不会用到未来数据

## 五、数据切片的详细流程

### 步骤 1：生成窗口

```python
窗口 0:
  train_start = "2015-01-01"
  train_end = "2016-12-31"
  valid_start = "2017-01-01"
  valid_end = "2017-01-31"
```

### 步骤 2：切片训练集

```python
train_feat, train_lbl = slice_data(
    features, labels, 
    "2015-01-01", "2016-12-31", 
    is_validation=False
)
```

**处理逻辑**：
1. 从完整数据中筛选时间在 [2015-01-01, 2016-12-31] 的数据
2. 如果标签需要未来10天数据，训练集结束日期调整为 2016-12-21
3. 过滤掉标签为 NaN 的数据

### 步骤 3：切片验证集

```python
valid_feat, valid_lbl = slice_data(
    features, labels, 
    "2017-01-01", "2017-01-31", 
    is_validation=True
)
```

**处理逻辑**：
1. 从完整数据中筛选时间在 [2017-01-01, 2017-01-31] 的数据
2. 由于标签需要未来10天数据，验证集结束日期调整为 2017-01-21
3. 过滤掉标签为 NaN 的数据

### 步骤 4：归一化处理

```python
# 对每个训练窗口单独计算归一化参数，避免数据泄露
train_feat_norm, norm_mean, norm_std = normalize_features(train_feat)

# 验证集使用训练集的归一化参数（不能使用验证集数据计算）
valid_feat_norm = (valid_feat - norm_mean) / norm_std
```

**关键点**：
- ✅ 归一化参数**只使用训练集**计算
- ✅ 验证集使用训练集的归一化参数
- ❌ **不能**使用验证集数据计算归一化参数（会导致数据泄露）

## 六、滚动窗口的完整流程

### 单个窗口的训练流程

```
窗口 N:
  ├─ 1. 生成窗口时间范围
  ├─ 2. 切片训练集和验证集
  ├─ 3. 检查样本数量（如果不足，跳过）
  ├─ 4. 计算归一化参数（仅使用训练集）
  ├─ 5. 归一化特征（训练集和验证集）
  ├─ 6. 训练模型（使用训练集）
  ├─ 7. 评估模型（使用验证集）
  ├─ 8. 保存模型和归一化参数
  └─ 9. 记录指标（IC 等）
```

### 多个窗口的滚动过程

```
窗口 0: 训练 [2015-01-01, 2016-12-31] 验证 [2017-01-01, 2017-01-31]
  ↓ 滚动 1 个月
窗口 1: 训练 [2015-02-01, 2017-01-31] 验证 [2017-02-01, 2017-02-28]
  ↓ 滚动 1 个月
窗口 2: 训练 [2015-03-01, 2017-02-28] 验证 [2017-03-01, 2017-03-31]
  ↓ 滚动 1 个月
...
窗口 N: 训练 [2022-12-01, 2024-11-30] 验证 [2024-12-01, 2024-12-31]
```

## 七、关键设计要点

### 1. 时间顺序严格保证

- ✅ 训练集时间 < 验证集时间（严格小于）
- ✅ 训练集和验证集之间没有重叠
- ✅ 每个窗口的训练集都是历史数据

### 2. 避免数据泄露

- ✅ 归一化参数只使用训练集计算
- ✅ 标签计算时考虑未来数据需求，提前结束日期
- ✅ 验证集不能用于训练

### 3. 适应市场变化

- ✅ 每个窗口独立训练，模型可以适应不同时期的市场特征
- ✅ 定期重新训练（每1个月），保持模型时效性

### 4. 评估模型稳定性

- ✅ 通过多个窗口的 IC 值评估模型在不同时期的稳定性
- ✅ 如果某个窗口表现异常，可以分析原因

## 八、实际运行示例

假设数据范围：2015-01-01 到 2024-12-31

```
窗口 0:
  训练: 2015-01-05 ~ 2016-12-21 (59498 样本)
  验证: 2017-01-03 ~ 2017-01-20 (1750 样本)
  训练 IC: 0.1234
  验证 IC: 0.1456

窗口 1:
  训练: 2015-02-02 ~ 2017-01-19 (59628 样本)
  验证: 2017-02-01 ~ 2017-02-17 (1750 样本)
  训练 IC: 0.1345
  验证 IC: 0.1567

... 共约 80+ 个窗口
```

## 九、常见问题

### Q1: 为什么验证窗口只有18天而不是31天？

**A**: 因为标签需要未来10天数据，所以验证窗口结束日期提前了10天：
- 原始：2017-01-01 到 2017-01-31（31天）
- 调整后：2017-01-01 到 2017-01-21（21天，但实际数据可能只有18个交易日）

### Q2: 窗口之间会有重叠吗？

**A**: 训练集之间会有重叠，但这是正常的：
- 窗口 0 训练集：2015-01-01 ~ 2016-12-31
- 窗口 1 训练集：2015-02-01 ~ 2017-01-31
- 重叠部分：2015-02-01 ~ 2016-12-31（这是正常的，因为都是历史数据）

### Q3: 为什么每个窗口都要重新训练？

**A**: 因为：
1. 市场环境在变化，旧模型可能不再适用
2. 使用最新的24个月数据训练，模型更贴近当前市场
3. 可以评估模型在不同时期的稳定性

### Q4: 如何选择滚动步长？

**A**: 
- **步长小（如1个月）**：更频繁地重新训练，模型更及时，但计算成本高
- **步长大（如3个月）**：计算成本低，但模型可能不够及时
- 一般建议：1-3个月，根据数据更新频率和计算资源决定

## 十、总结

滚动窗口训练的核心思想：
1. **时间顺序**：严格保证训练集时间 < 验证集时间
2. **避免泄露**：归一化和数据处理都只使用训练集
3. **定期更新**：通过滚动窗口定期重新训练模型
4. **稳定评估**：通过多个窗口评估模型在不同时期的性能

这种方法的优势是能够**模拟真实场景**，确保模型在实际应用中的表现与训练时一致。


